{
  "tools": [
    {
      "name": "search_metadata",
      "description": "Keyword-based search for data assets in OpenMetadata. Best when you know specific names, owners, tags, tiers, services, or column names. Use this for exact lookups (e.g., 'find table X', 'tables owned by team Y'), filtering by metadata properties, counting assets, and aggregations. Supports pagination and advanced OpenSearch DSL queries. Choose this over semantic_search when the query targets known identifiers or structured attributes.",
      "parameters": {
        "description": "Use 'query' for keyword search or 'queryFilter' for advanced OpenSearch DSL. Best for exact matches and filtering by metadata properties.",
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Natural language search query. Use this for simple searches. Examples: 'tables owned by marketing', 'dashboards with customer data', 'tier1 tables', 'tables with column SKU', 'BigQuery services'. The query will be automatically converted to an optimized search."
          },
          "entityType": {
            "type": "string",
            "description": "Filter by entity type (auto-detected if not specified). Use singular form: table, dashboard, topic, pipeline, database, databaseService, glossary, glossaryTerm, mlmodel, container, chart, metric, user, team, domain, dataProduct."
          },
          "queryFilter": {
            "type": "string",
            "description": "Advanced: Direct OpenSearch JSON query string for precise control. Only use if you can generate valid OpenSearch DSL. When provided, this overrides the 'query' parameter. Must include entityType filter. Example: '{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"owners.name\": \"marketing\"}}]}}'. Key rules: Use singular entityType, 'owners.name' (plural), tier format is 'Tier.Tier1', columns are NOT nested."
          },
          "from": {
            "type": "integer",
            "description": "In case the request more than 'size' results, this is the offset from the first result you want to fetch. Default is 0.",
            "default": 0
          },
          "size": {
            "type": "integer",
            "description": "Number of results to return. Default is 10, we can iteratively page through results by increasing 'from'. Maximum allowed is 50.",
            "default": 10
          },
          "includeDeleted": {
            "type": "boolean",
            "description": "Include deleted entities in search results. Default is false.",
            "default": false
          },
          "fields": {
            "type": "string",
            "description": "Comma-separated additional fields to include. Default returns: name, displayName, fullyQualifiedName, description, entityType, service, database, databaseSchema, serviceType, href, tags, owners, tier, tableType, columnNames.\n\nAdditional fields by entity type:\n- Table entities: columns, schemaDefinition, queries, upstreamLineage, entityRelationship\n- Topic entities: messageSchema, partitions, replicationFactor  \n- Dashboard entities: charts, dataModels, project\n- Pipeline entities: tasks, pipelineUrl, scheduleInterval\n- All entities: createdAt, updatedAt, changeDescription, extension, domain, dataProducts, lifeCycle, sourceHash\n\nExample: 'columns,queries' for table column details and sample queries."
          },
          "includeAggregations": {
            "type": "boolean",
            "description": "Whether to include aggregation data (facets) in the response. Defaults to false to optimize LLM context size. Set to true only when you need aggregation statistics like counts by service type, owner, tags, etc. Aggregations can significantly increase response size.",
            "default": false
          },
          "maxAggregationBuckets": {
            "type": "integer",
            "description": "Maximum number of aggregation buckets to return per field when includeAggregations is true. Limits response size to prevent context overflow. Default is 10, maximum allowed is 50.",
            "default": 10
          }
        },
        "required": [],
        "examples": [
          {
            "description": "Simple search - Find tables owned by a team",
            "query": "tables owned by marketing",
            "entityType": "table"
          },
          {
            "description": "Simple search - Find customer-related data",
            "query": "tables with customer data"
          },
          {
            "description": "Simple search - Find tier1 tables",
            "query": "tier1 tables",
            "entityType": "table"
          },
          {
            "description": "Simple search - Find dashboards",
            "query": "sales dashboards",
            "entityType": "dashboard"
          },
          {
            "description": "Simple search with pagination",
            "query": "tables",
            "size": 20,
            "from": 0
          },
          {
            "description": "Advanced - Owner filter with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"owners.name\": \"marketing\"}}]}}"
          },
          {
            "description": "Advanced - Column search with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"match\": {\"columns.name\": \"customer\"}}]}}"
          },
          {
            "description": "Advanced - Tier1 tables with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"tier.tagFQN\": \"Tier.Tier1\"}}]}}"
          },
          {
            "description": "Advanced - Tag filtering with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"tags.tagFQN\": \"PII.Sensitive\"}}]}}"
          },
          {
            "description": "Advanced - Aggregation query for counting",
            "queryFilter": "{\"size\": 0, \"query\": {\"bool\": {\"must\": [{\"term\": {\"entityType\": \"databaseService\"}}, {\"term\": {\"serviceType\": \"BigQuery\"}}]}}, \"aggs\": {\"total_count\": {\"value_count\": {\"field\": \"_id\"}}}}"
          }
        ]
      }
    },
    {
      "name": "semantic_search",
      "description": "Meaning-based discovery of data assets using vector embeddings. Best for exploratory or vague queries where you don't know exact names â€” it finds conceptually related assets even when no keywords match. Use this when the user describes what data they need in plain language (e.g., 'tables about customer spending behavior', 'anything related to revenue forecasting'). Returns entity summaries with name, columns, description, and metadata. Choose this over search_metadata when the query is about meaning or concepts rather than specific identifiers or attributes.",
      "parameters": {
        "description": "Use 'query' to describe what you're looking for in plain language. The system finds conceptually similar assets using vector similarity. Optionally filter by entity type, service, or tags.",
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Natural language query describing what you're looking for. Semantic search finds conceptually similar results, so phrasing matters more than exact keywords. Examples: 'customer purchase history', 'tables tracking revenue metrics', 'pipeline processing user events'."
          },
          "filters": {
            "type": "object",
            "description": "Optional filters to narrow results. Keys are field names and values are arrays of allowed values. Supported filter fields: 'entity_type' (e.g., ['table', 'dashboard']), 'service' (e.g., ['BigQuery', 'Snowflake']), 'tags' (e.g., ['PII.Sensitive']). Example: {\"entity_type\": [\"table\"], \"service\": [\"BigQuery\"]}.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "size": {
            "type": "integer",
            "description": "Number of parent entities to return. Default is 10, maximum is 50.",
            "default": 10
          },
          "k": {
            "type": "integer",
            "description": "Number of nearest neighbors to consider internally (KNN parameter). Higher values may improve result quality at the cost of latency. Default is 100.",
            "default": 100
          },
          "threshold": {
            "type": "number",
            "description": "Minimum similarity score threshold (0.0 to 1.0). Results below this score are excluded. Default is 0.0 (no filtering). Use higher values like 0.5 or 0.7 to get only highly relevant results.",
            "default": 0.0
          }
        },
        "required": ["query"],
        "examples": [
          {
            "description": "Find tables related to customer purchases",
            "query": "customer purchase history"
          },
          {
            "description": "Find dashboards about revenue in BigQuery",
            "query": "revenue metrics dashboard",
            "filters": {"entity_type": ["dashboard"], "service": ["BigQuery"]}
          },
          {
            "description": "High-confidence search for PII data",
            "query": "personal identifiable information",
            "threshold": 0.5
          },
          {
            "description": "Find pipeline assets processing user events",
            "query": "user event processing pipeline",
            "filters": {"entity_type": ["pipeline"]}
          }
        ]
      }
    },
    {
      "name": "get_entity_details",
      "description": "Get detailed information about a specific entity. Response is optimized for LLM context by excluding verbose metadata fields.",
      "parameters": {
        "description": "Fqn is the fully qualified name of the entity. Entity type could be table, topic etc.",
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity"
          },
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the entity"
          }
        },
        "required": [
          "entityType",
          "fqn"
        ]
      }
    },
    {
      "name": "create_glossary_term",
      "description": "Creates a new Glossary Term. Note that a glossary term must be part of a Glossary, so the glossary must be specified in the parameters. If you can't find the right glossary to use, respond back to the user to create a new Glossary first. Note that you can help the user to create the Glossary as well. If you don't find any Glossary that could be related, please list to the user the available Glossaries so users can choose if they want to create or reuse something. Also, note that glossary terms can be hierarchical: for example, a glossary term 'Accounts' can have a child term 'Credit Account', 'Savings Account', etc. So if you find any terms that can be related, it might make sense to create a new term as a child of an existing term.",
      "parameters": {
        "type": "object",
        "properties": {
          "glossary": {
            "type": "string",
            "description": "Glossary in which the term belongs. This should be its fully qualified name."
          },
          "parentTerm": {
            "type": "string",
            "description": "Optional parent term for the new term. This should be its fully qualified name defined as <glossary>.<term>. If the Glossary Term has other parents, the Fully Qualified Name will be <glossary>.<parent>...<term>. If not provided, the term will be created at the root level of the glossary."
          },
          "name": {
            "type": "string",
            "description": "Glossary Term name."
          },
          "description": {
            "type": "string",
            "description": "Glossary Term description."
          },
          "owners": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "glossary",
          "name",
          "description"
        ]
      }
    },
    {
      "name": "create_glossary",
      "description": "Creates a new Glossary. A Glossary is a collection of terms that are used to define the business vocabulary of an organization. Typically, similar terms are grouped together in a Glossary. For example, a Glossary names 'Marketing' could contain terms like 'Campaign', 'Lead', 'Opportunity', etc.",
      "parameters": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Glossary Term name."
          },
          "description": {
            "type": "string",
            "description": "Glossary Term description."
          },
          "owners": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          },
          "reviewers": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          },
          "mutuallyExclusive": {
            "type": "boolean",
            "description": "Glossary terms that are direct children in this glossary are mutually exclusive. When mutually exclusive is `true` only one term can be used to tag an entity. When mutually exclusive is `false`, multiple terms from this group can be used to tag an entity. This is an important setting. If you are not sure, ask the user to clarify. If the user doesn't know, set it to `false`.",
            "default": false
          }
        },
        "required": [
          "name",
          "description",
          "mutuallyExclusive"
        ]
      }
    },
    {
      "name": "patch_entity",
      "description": "Patches an Entity based on a JSONPatch. Beforehand the Entity should be validated by finding it and creating a proper patch.",
      "parameters": {
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Entity Type to patch."
          },
          "fqn": {
            "type": "string",
            "description": "Fully Qualified Name of the Entity to be patched."
          },
          "patch": {
            "type": "string",
            "description": "JSONPatch as String format."
          }
        },
        "required": [
          "entityType",
          "fqn",
          "patch"
        ]
      }
    },
    {
      "name": "get_entity_lineage",
      "description": "Get detailed information about lineage (upstream/downstream dependencies) of a specific entity. Use this for root cause (upstream entities) or impact (downstream entities) analysis and explaining dependencies between entities.",
      "parameters": {
        "description": "Fqn is the fully qualified name of the entity. Entity type could be table, topic etc.",
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity"
          },
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the entity"
          },
          "upstreamDepth": {
            "type": "integer",
            "description": "Number of upstream hops to traverse. Default is 3, maximum is 10 to prevent excessive response size.",
            "default": 3
          },
          "downstreamDepth": {
            "type": "integer",
            "description": "Number of downstream hops to traverse. Default is 3, maximum is 10 to prevent excessive response size.",
            "default": 3
          }
        },
        "required": [
          "entityType",
          "fqn"
        ]
      }
    },
    {
      "name": "create_lineage",
      "description": "This tool can be used to create lineage between two assets. It takes the source and target asset details and creates a lineage relationship between them.",
      "parameters": {
        "description": "Required to create lineage between two assets.",
        "type": "object",
        "properties": {
          "fromEntity": {
            "description": "Source Entity.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "description": "Type of entity"
              },
              "id": {
                "type": "string",
                "description": "Id of the entity"
              }
            },
            "required": ["type", "id"]
          },
          "toEntity": {
            "description": "Destination Entity.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "description": "Type of entity"
              },
              "id": {
                "type": "string",
                "description": "Id of the entity"
              }
            },
            "required": ["type", "id"]
          }
        },
        "required": [
          "fromEntity",
          "toEntity"
        ]
      }
    },
    {
      "name": "get_test_definitions",
      "description": "This tool can be used to get all the test definitions in the OpenMetadata. It returns a list of test definitions. These test definition can be used to create a test case for a table or a table's column. While creating column test for entity, column data type should be in supportedDataTypes of parameterDefinition.",
      "parameters": {
        "description": "These test definition are required to create a test case for table or a table's column.",
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Entity Type can be 'TABLE' for table asset/entity or 'COLUMN' for column level tests. Default is TABLE."
          },
          "testPlatform": {
            "type": "string",
            "description": "Default value can be 'OpenMetadata'. Other Platform can be 'OpenMetadata','GreatExpectations', 'DBT', 'Deequ', 'Soda', 'Other' if the user specifically gives the platform name."
          },
          "after": {
            "type": "string",
            "description": "This can be used to paginate the results. In the response you will get a nextCursor value, which can be used to get the next set of results. For the first call, this should be ignored."
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of results to return. Default is 10."
          }
        },
        "required": [
          "entityType"
        ]
      }
    },
    {
      "name": "create_test_case",
      "description": "This tool can be used to create a test case for a table or a table's column. It needs test definitions. These test definition can be found using the get_test_definitions tool. If this fails do not do other operations.",
      "parameters": {
        "description": "This tool can be used to create a test case for a table or a table's column. It requires the test definition and the entity (table or column) to be tested.",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the test case. Either the user tells the name or auto generate a name based on the test definition and entity fqn."
          },
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the table for which the test case is being added. Always use the table FQN, not the column FQN."
          },
          "columnName": {
            "type": "string",
            "description": "Name of the column to test. Required for column-level test definitions (entityType=COLUMN). This is just the column name, not the full FQN. For example, 'shop_id' not the full table.column path."
          },
          "entityType": {
            "type": "string",
            "description": "Type of the entity for which the test case is being added. Default is 'table'. It can only be one of these values 'container', 'workflowDefinition', 'testSuite', 'pipelineService', 'messagingService', 'type', 'dataContract', 'metadataService', 'appMarketPlaceDefinition', 'tag', 'dashboard', 'app', 'dataProduct', 'persona', 'workflow', 'kpi', 'apiService', 'query', 'searchIndex', 'classification', 'dashboardDataModel', 'glossary', 'apiEndpoint', 'storageService', 'domain', 'topic', 'databaseSchema', 'role', 'dataInsightChart', 'bot', 'mlmodelService', 'document', 'ingestionPipeline', 'database', 'searchService', 'testConnectionDefinition', 'webAnalyticEvent', 'table', 'policy', 'storedProcedure', 'databaseService', 'eventsubscription', 'dashboardService', 'apiCollection', 'team', 'mlmodel', 'glossaryTerm', 'pipeline', 'dataInsightCustomChart', 'metric', 'report', 'chart', 'user', 'testCase', 'testDefinition'."
          },
          "testDefinitionName": {
            "type": "string",
            "description": "Fully qualified name of the test definition to be used for the test case."
          },
          "description": {
            "type": "string",
            "description": "Description of the test case. This can be auto generated based on entity details, the test definition and type of test."
          },
          "parameterValues": {
            "type": "array",
            "description": "Parameter values for the test case. This is an array of objects, where each object contains the parameter name (this is 'name' from parameter definition in test definition) and value (can be asked from user or auto supplied). These parameter can be found from the testDefinitions from `parameterDefinition` which has name, description, dataType and whether it is required mandatorily.",
            "items": {
              "type": "object",
              "description": "Parameter values that can be passed for a Test Case.",
              "properties": {
                "name": {
                  "description": "Name of the parameter. Must match the parameter names in testCaseParameterDefinition",
                  "type": "string"
                },
                "value": {
                  "description": "value to be passed for the Parameters. These are input from Users. We capture this in string and convert during the runtime.",
                  "type": "string"
                }
              },
              "required": [
                "name",
                "value"
              ]
            }
          }
        },
        "required": [
          "name",
          "fqn",
          "testDefinitionName",
          "parameterValues"
        ]
      }
    },
    {
      "name": "root_cause_analysis",
      "description": "Performs comprehensive root cause analysis via data quality lineage. First identifies upstream failures that may be causing issues for the specified asset. If failures are found, automatically analyzes downstream impact to show which assets may be affected. Returns both upstream root causes and downstream impact analysis. In the response 'status' indicates whether upstream failures were found. If 'status' is 'failed', the 'upstreamAnalysis' can be used to identify the nodes and edges leading to failures and downstreamAnalysis can tell what all nodes in downstream are impacted. If 'status' is 'success', it means no upstream failures were found, and downstream impact analysis was not performed.",
      "parameters": {
        "type": "object",
        "properties": {
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the entity to analyze for root cause analysis"
          },
          "upstreamDepth": {
            "type": "integer",
            "description": "Number of levels upstream to traverse for root cause analysis. Default is 3.",
            "default": 3
          },
          "downstreamDepth": {
            "type": "integer",
            "description": "Number of levels downstream to traverse for impact analysis (only performed if upstream failures are found). Default is 3.",
            "default": 3
          },
          "queryFilter": {
            "type": "string",
            "description": "Optional Elasticsearch query filter to refine the lineage search results"
          },
          "includeDeleted": {
            "type": "boolean",
            "description": "Whether to include deleted entities in the analysis. Default is false.",
            "default": false
          },
          "entityType": {
            "type": "string",
            "description": "Required mandatorily for this tool. The OpenMetadata entities are categorized as follows: Service Entities include databaseService, messagingService, apiService, dashboardService, pipelineService, storageService, mlmodelService, metadataService, and searchService; Data Asset Entities include apiCollection, apiEndpoint, table, storedProcedure, database, databaseSchema, dashboard, dashboardDataModel, pipeline, chart, topic, searchIndex, mlmodel, and container; User Entities include user and team; Domain entities include domain and dataProduct; and Governance entities include metric, glossary, and glossaryTerm."
          }
        },
        "required": [
          "fqn",
          "entityType"
        ]
      }
    }
  ]
}
